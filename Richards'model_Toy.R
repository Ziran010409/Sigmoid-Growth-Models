#For Richards' model
library(Rtwalk)
library(knitr)

#insert the data, plot data and prepare it
mass <- c(6.25,10,20,23,26,27.6,29.8,31.6,37.2,41.2,48.7,54,54,63,66,72,72.2,
          76,75)

days.since.birth <- c(31,62,93,99,107,113,121,127,148,161,180,214,221,307,
                      452,482,923, 955,1308)

plot(days.since.birth, mass, xlab = "time (days)", ylab = "mass", 
     cex.axis = 1.5, cex.lab = 1.5, pch = 19) 

y <- log(mass)  #since we have taken the log of the likelihood and the ODE before
time <- days.since.birth/365.24 #Time in years


#the analytic solution of richards' model ode
richardsode <- function(t, lambda, kappa, N0, beta, log = FALSE){
  ll <-  log(kappa) + log(N0) - (1/beta)*log( N0^beta + (kappa^beta-N0^beta)*exp(-lambda*t*beta))
  if (log)  return(ll)
  else return(exp(ll))
}


# Define the negative log-likelihood function for Richards' growth model
loglikR <- function(par){
  lambda <- exp(par[1])
  kappa <- exp(par[2])
  N0 <- exp(par[3])
  beta <- exp(par[4])
  sigma <- exp(par[5])
  
  loglik <- sum( dnorm( y - richardsode(time, lambda, kappa, N0, beta, log = TRUE), 
                        mean = 0, sd = sigma, log = TRUE) )
  
  return(-loglik)
}

###################################
# Maximum Likelihood Estimation (MLE)
################################### rep(0.1, 5)
OPTR <- nlminb(start = rep(0.1, 5), objective = loglikR)
MLER <- exp(OPTR$par)

fitrichards <- Vectorize(function(t) richardsode(t, MLER[1], MLER[2], MLER[3],MLER[4], log = FALSE))

plot(time, mass, xlab = "time (years)", ylab = "mass", main = "Richards' model",
     cex.axis = 1.5, cex.lab = 1.5, pch =19) 
curve(fitrichards, 0,4, add=TRUE, lwd = 2, col = "blue")

#bic
bic <- 2*loglikR(par = OPTR$par)+3*log(19)

#################################3
# profile likelihood of the parameters (lecture note 3.4, page 7.2)
##################################
# Required quantities
p <- 5

MR <- OPTR$objective

prof.likR <- function(par1, ind){
  
  tempf <- function(par){
    tempv <- rep(0,p)
    tempv <- replace(x = tempv, c(1:p)[-ind] , par)
    tempv <- replace(x = tempv, ind , par1)
    out0 <- loglikR(tempv)
    return(out0)
  } 
  
  out <-  -nlminb(OPTR$par[-ind],tempf, control = list(iter.max = 10000))$objective + MR
  
  return(exp(out))
}

prof_indR <- Vectorize(function(par) prof.likR(log(par),indprof)) 

indprof <- 1
curve(prof_indR,10,30, n = 200, lwd = 2, xlab = expression(lambda), ylab = "Profile Likelihood",
      cex.axis = 1.5, cex.lab = 1.5)
#n is the number of points, 6-10 is the range(xlimit),

# Profile likelihood of Parameter 2
indprof <- 2
curve(prof_indR,60,80 , n = 200, lwd = 2, xlab = expression(kappa), ylab = "Profile Likelihood",
      cex.axis = 1.5, cex.lab = 1.5)

# Profile likelihood of Parameter 3
indprof <- 3
curve(prof_indR,1,5 , n = 200, lwd = 2, xlab = expression(N0), ylab = "Profile Likelihood",
      cex.axis = 1.5, cex.lab = 1.5)

# Profile likelihood of Parameter 4
indprof <- 4
curve(prof_indR,0.1,0.6 , n = 200, lwd = 2, xlab = expression(beta), ylab = "Profile Likelihood",
      cex.axis = 1.5, cex.lab = 1.5)

## Profile likelihood of Parameter 5
indprof <- 5
curve(prof_indR,0.03,0.10 , n = 200, lwd = 2, xlab = expression(beta), ylab = "Profile Likelihood",
      cex.axis = 1.5, cex.lab = 1.5)


####################################
# Bayesian Inference for Richards' growth model
####################################
#SupportR <- function(x) { TRUE }

#X0R <- function(x) { OPTR$par + runif(5, -0.01, 0.01) }

#posterior function
logpostR <- function(par){
  lambda <- exp(par[1])
  kappa <- exp(par[2])
  N0 <- exp(par[3])
  beta <- exp(par[4])
  sigma <- exp(par[5])
  
  loglik <- sum( dnorm( y - richardsode(time, lambda, kappa, N0, beta, log = TRUE), 
                        mean = 0, sd = sigma, log = TRUE) )
  
  logprior <- sum(dnorm(par,0,1,log=TRUE)) #use N(0,1) prior
  
  logjacob <- sum(par)
  
  return(-loglik - logprior - logjacob)
}

#set parameters for the adaptive Metropolis within Gibbs sampler
#adaptive metropolis within Gibbs is a specific Bayesian sampling method that is more conservative
#adaptive metropolis within Gibbs is a type of MCMC sampler
library(spBayes)
n.batch <- 2000  #higher n.batch values improving convergence but increase computational time
batch.length <- 60  #larger batch length improving convergence but increase computational time
#adjusting the parameters to ensure the MCMC sampler converges properly.
#convergence refers to the property where the Markov chain generated by the sampler reaches 
#a stationary distribution that represents the posterior distribution of the parameters
lp <- function(par) -logpostR(par)

inits <- OPTR$par
set.seed(1234)
infoR <- adaptMetropGibbs(ltd=lp, starting=inits, accept.rate=0.44, batch=n.batch, 
                          batch.length=batch.length, report=100, verbose=FALSE)
chainR <- infoR$p.theta.samples[,1:5]
#extracts the parameter samples from the sampler results
#how do I check converge?

# Burning and thinning the chain
#burn <- 1e4
#thin <- 100
#you need to adjusting the parameter MCMC sampler
#NS <- n.batch*batch.length
#ind <- seq(burn,NS,thin)

ind=seq(10000,110000,100) 

summR <- apply(exp(chainR[ind,1:5]),2,summary)
colnames(summR) <- c("lambda","kappa","N_0","beta","sigma")
kable(summR, digits = 3)
sd <- apply(exp(chainR[ind,1:5]),2,sd)
mean <- apply(chainR[ind,1:5],2,mean) 
#bic
bic_bayesian <- 2*loglikR(par = mean)+3*log(19) #bic= -41.98852



#compare the estimates from MLE and Bayesian inference
cbind(exp(OPTR$par),colMeans(exp(chainR[ind,])))

# extract sample
lambdap <- exp(chainR[ind,1])
kappap <- exp(chainR[ind,2])
N0p <- exp(chainR[ind,3])
betap <- exp(chainR[ind,4])
sigmap <- exp(chainR[ind,5])
# plot histograms of the thinned samples for each parameter
hist(lambdap,main = "", xlab = expression(lambda))
hist(kappap,main = "", xlab = expression(kappa))
hist(N0p,main = "", xlab = expression(N_0))
hist(betap,main = "", xlab = expression(beta))
hist(sigmap,main = "", xlab = expression(sigma))

plot(lambdap,main = "", xlab = expression(lambda))
plot(kappap,main = "", xlab = expression(kappa))
plot(N0p,main = "", xlab = expression(N_0))
plot(betap,main = "", xlab = expression(beta))
plot(sigmap,main = "", xlab = expression(sigma))
#if MCMC sampler converges nicely, the plots should not have evident trends
#you can see there are no obvious trends exist.
#If trends exist, we can try different prior and different value of n.batch, batch.length 
#and accpet.rate to see if we can remove the trends 


####################################
# Posterior envelopes and mean growth curve
####################################
# Creating the posterior envelopes
tvec <- seq(0,4,by = 0.01) #time points, used for plotting the growth curve
ntvec <- length(tvec) #number of time points

# Richards' model
NCIR <- matrix(0, ncol = ntvec, nrow = length(ind)) 
#empty matrix with ncol=number of time points, nrow=number of posterior samples

for(j in 1:length(ind)){
  for(k in 1:ntvec){
    NCIR[j,k] <- richardsode(tvec[k],lambdap[j], kappap[j],N0p[j],betap[j]) 
  }
} 
#filled the emty NCIL matrix with the value of Richards' growth model for each 
#combination of posterior samples and time points 

NR <-  colMeans(NCIR) #mean grwoth curve 

#calculates the quantiles of the posterior distribution for each time point
NCIRL <- apply(NCIR, 2, function(x) quantile(x, probs = 0.025))
NCIRU <- apply(NCIR, 2, function(x) quantile(x, probs = 0.975))

#Richards' model
plot(tvec,  NR, type = "l", ylim = c(0,100), xlab = "Time", ylab = "Mass", main = "Richards' model",
     cex.axis = 1.5, cex.lab = 1.5, lwd =2, lty = 2)
points(tvec,  NCIRL, col = "gray", type = "l")
points(tvec,  NCIRU, col = "gray", type = "l")
#add the upper and lower quantile as the grey lines
polygon(c(tvec, rev(tvec)),c(NCIRL[order(tvec)], rev(NCIRU[order(tvec)])),
        col = "gray", border = NA)
#filled the area with a gray polygon to represent the posterior envelopes
points(tvec,  NR,type = "l", col = "black", lwd = 2, lty =2)
#Adds the mean growth curve(becasue when you filled with grey polygon, the dash line we plot
# before would be covered, so we plot the line again)
points(time, mass, xlab = "time (years)", ylab = "mass", 
       cex.axis = 1.5, cex.lab = 1.5, pch = 19) 
#Adds the observed data points







  