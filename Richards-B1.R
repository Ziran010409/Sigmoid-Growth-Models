#For Richards' model
library(Rtwalk)
library(knitr)

############# prepare dataset
library(growthcurver)
head(growthdata[,c("time","B1")],1) #B1 well

plot(growthdata[,c("time","B1")])

index <- which(growthdata[,1] >= 7 & growthdata[,1] <= 24)

mass <- as.numeric(as.vector(growthdata[index,'B1'])) #mass here means the absorbance readings
time <- as.numeric(as.vector(growthdata[index,1])) #Time in years
time <- time - min(time)

plot(time, mass)
N0 <- mass[1]

y <- log(mass) 

# Richards' model
richardsode <- function(t, lambda, kappa, beta, log = FALSE){
  ll <-  log(kappa) + log(N0) - (1/beta)*log( N0^beta + (kappa^beta-N0^beta)*exp(-lambda*t*beta))
  if (log)  return(ll)
  else return(exp(ll))
}


# Define the negative log-likelihood function for Richards' growth model
loglikR <- function(par){
  lambda <- exp(par[1])
  kappa <- exp(par[2])
  beta <- exp(par[3])
  sigma <- exp(par[4])
  
  loglik <- sum( dnorm( y - richardsode(time, lambda, kappa, beta, log = TRUE), 
                        mean = 0, sd = sigma, log = TRUE) )
  
  return(-loglik)
}

###################################
# Maximum Likelihood Estimation (MLE)
################################### rep(0.1, 5)
OPTR <- nlminb(start = rep(-1, 4), objective = loglikR)
MLER <- exp(OPTR$par)
kable(MLER, digits = 3)
fitrichards <- Vectorize(function(t) richardsode(t, MLER[1], MLER[2], MLER[3], log = FALSE))

plot(time, mass, xlab = "time (years)", ylab = "absorbance readings", main = "Richards' model",
     cex.axis = 1.5, cex.lab = 1.5, pch =19) 
curve(fitrichards, add=TRUE, lwd = 2, col = "blue")

#bic
bic <- 2*loglikR(par = OPTR$par)+2*log(103)



####################################
# Bayesian Inference for Richards' growth model
####################################
#SupportR <- function(x) { TRUE }

#X0R <- function(x) { OPTR$par + runif(5, -0.01, 0.01) }

#posterior function
logpostR <- function(par){
  lambda <- exp(par[1])
  kappa <- exp(par[2])
  beta <- exp(par[3])
  sigma <- exp(par[4])
  
  loglik <- sum( dnorm( y - richardsode(time, lambda, kappa, beta, log = TRUE), 
                        mean = 0, sd = sigma, log = TRUE) )
  
  logprior <- sum(dnorm(par,0,1,log=TRUE)) #use N(0,1) prior
  
  logjacob <- sum(par)
  
  return(-loglik - logprior - logjacob)
}

#set parameters for the adaptive Metropolis within Gibbs sampler
#adaptive metropolis within Gibbs is a specific Bayesian sampling method that is more conservative
#adaptive metropolis within Gibbs is a type of MCMC sampler
library(spBayes)
n.batch <- 2000  #higher n.batch values improving convergence but increase computational time
batch.length <- 60  #larger batch length improving convergence but increase computational time
#adjusting the parameters to ensure the MCMC sampler converges properly.
#convergence refers to the property where the Markov chain generated by the sampler reaches 
#a stationary distribution that represents the posterior distribution of the parameters
lp <- function(par) -logpostR(par)

inits <- OPTR$par
set.seed(1234)
infoR <- adaptMetropGibbs(ltd=lp, starting=inits, accept.rate=0.44, batch=n.batch, 
                          batch.length=batch.length, report=100, verbose=FALSE)
chainR <- infoR$p.theta.samples[,1:4]
#extracts the parameter samples from the sampler results
#how do I check converge?

# Burning and thinning the chain
#burn <- 1e4
#thin <- 100
#you need to adjusting the parameter MCMC sampler
#NS <- n.batch*batch.length
#ind <- seq(burn,NS,thin)

ind=seq(10000,110000,100) 

summR <- apply(exp(chainR[ind,1:4]),2,summary)
colnames(summR) <- c("lambda","kappa","beta","sigma")
kable(summR, digits = 3)
sd <- apply(exp(chainR[ind,1:4]),2,sd)
mean <- apply(chainR[ind,1:4],2,mean) 
#bic
bic_bayesian <- 2*loglikR(par = mean)+2*log(103) 



#compare the estimates from MLE and Bayesian inference
cbind(exp(OPTR$par),colMeans(exp(chainR[ind,])))

lambdap <- exp(chainR[ind,1])
kappap <- exp(chainR[ind,2])
betap <- exp(chainR[ind,3])
sigmap <- exp(chainR[ind,4])


####################################
# Posterior envelopes and mean growth curve
####################################
# Creating the posterior envelopes
tvec <- seq(0,17,by = 0.01) #time points, used for plotting the growth curve
ntvec <- length(tvec) #number of time points

# Richards' model
NCIR <- matrix(0, ncol = ntvec, nrow = length(ind)) 
#empty matrix with ncol=number of time points, nrow=number of posterior samples

for(j in 1:length(ind)){
  for(k in 1:ntvec){
    NCIR[j,k] <- richardsode(tvec[k],lambdap[j], kappap[j],betap[j]) 
  }
} 
#filled the emty NCIL matrix with the value of Richards' growth model for each 
#combination of posterior samples and time points 

NR <-  colMeans(NCIR) #mean grwoth curve 

#calculates the quantiles of the posterior distribution for each time point
NCIRL <- apply(NCIR, 2, function(x) quantile(x, probs = 0.025))
NCIRU <- apply(NCIR, 2, function(x) quantile(x, probs = 0.975))

#Richards' model
plot(tvec,  NR, type = "l", xlab = "Time", ylab = "absorbance readings", main = "Richards' model",
     cex.axis = 1.5, cex.lab = 1.5, lwd =2, lty = 2)
points(tvec,  NCIRL, col = "gray", type = "l")
points(tvec,  NCIRU, col = "gray", type = "l")
#add the upper and lower quantile as the grey lines
polygon(c(tvec, rev(tvec)),c(NCIRL[order(tvec)], rev(NCIRU[order(tvec)])),
        col = "gray", border = NA)
#filled the area with a gray polygon to represent the posterior envelopes
points(tvec,  NR,type = "l", col = "black", lwd = 2, lty =2)
#Adds the mean growth curve(becasue when you filled with grey polygon, the dash line we plot
# before would be covered, so we plot the line again)
points(time, mass, xlab = "time (years)", ylab = "mass", 
       cex.axis = 1.5, cex.lab = 1.5, pch = 19) 
#Adds the observed data points
